package edu.aem.training.eventhandler;

import com.day.cq.wcm.api.PageManager;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.jcr.api.SlingRepository;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.jackrabbit.api.observation.JackrabbitEvent;

import javax.jcr.Node;
import javax.jcr.Property;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.observation.EventIterator;
import javax.jcr.observation.EventListener;
import javax.jcr.observation.ObservationManager;
import javax.jcr.observation.Event;
import java.util.Arrays;
import java.util.HashMap;

import com.day.cq.wcm.api.Page;


@Component(
        label = "AEM Event Listener Auto Versioning",
        immediate = true
)
@Service
public class AutoVersionEventListener implements EventListener {

    private final String EVENT_LISTENER_PATH = "/content/myapp";

    private Logger log = LoggerFactory.getLogger(this.getClass());

    private ComponentContext componentContext;

    @Reference
    private SlingRepository repository;

    @Reference
    private ResourceResolverFactory resolverFactory;

    private Session session;

    private ObservationManager observationManager;

    public void run() {
        log.info("Running...");
    }

    // Place app logic here to define the AEM Custom Event Handler
    protected void activate(ComponentContext ctx) {

        this.componentContext = ctx;

        try {
            // Invoke the adapTo method to create a Session
//            ResourceResolver resourceResolver = resolverFactory.getAdministrativeResourceResolver(null);
//            session = resourceResolver.adaptTo(Session.class);
            session = repository.loginAdministrative(null);

            // Setup the event handler to responde to a new claim under content/claim...
            observationManager = session.getWorkspace().getObservationManager();
            final String[] types = {"cq:PageContent"};
            // Define the path
            final String path = EVENT_LISTENER_PATH;
            observationManager.addEventListener(this,
                    Event.NODE_ADDED | Event.NODE_MOVED | Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED | Event.PROPERTY_REMOVED,
                    path,
                    true,        // [isDeep] events whose associated node is at path or within its subtree
                    null,    // [uuid] events whose associated node has one of the UUID's in this list
                    types,   // [nodeTypeName] events whose associated node has one of the node types in this list
                    false      // [noLocal] events generated by the session through which the listener was registered are not ignored
            );

            log.info("Observation property to {} nodes under {}", Arrays.asList(types), path);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected void deactivate(ComponentContext componentContext) throws RepositoryException {

        if(observationManager != null) {
            observationManager.removeEventListener(this);
        }

        if(session != null) {
            session.logout();
            session = null;
        }
    }

    // Define app logic that is fired when the even occurs - simply track the time
    // when the event occured
    public void onEvent(EventIterator eventIterator) {
        log.info("onEvent");


        try {

            String pagePath = "";

            while (eventIterator.hasNext()) {

                Event event = eventIterator.nextEvent();

                // IMPORTANT!
                //
                // JCR Events are NOT cluster-aware and this event listener will be invoked on every node in the cluster.

                // Check if this event was spawned from the server this event handler is running on or from another
                if (event instanceof JackrabbitEvent && ((JackrabbitEvent) event).isExternal()) {
                    // Event did NOT originate from this server

                    // Skip, Let only the originator process;

                    // This is usual to avoid having the same processing happening for every node in a cluster. This
                    // is almost always the case when the EventListener modifies the JCR.

                    // A possible use-case for handling the event on EVERY member of a cluster would be clearing out an
                    // in memory (Service-level) cache.

                    continue;
                } else {
                    // Event originated from THIS server
                    // Continue processing this Event
                }

                String path = event.getPath();

                if(isExcludedProperty(path)) {
                    continue;
                }

                String id = event.getIdentifier();

                log.info("Identifier: " + id);
                log.info("path: " + path);

                // Extract base folder of current node (path without /page-name/jcr:content)
                String baseFolder = extractBaseFolder(path);

                // Process only pages of EVENT_LISTENER_PATH
                if(!EVENT_LISTENER_PATH.equals(baseFolder)) {
                    log.info("Wrong path: " + path);
                    log.info("Identifier: " + id);
                    log.info("Base folder: " + baseFolder);
                    continue;
                }

                // Extract page path EVENT_LISTENER_PATH/page-name
                pagePath = extractPagePath(path);
                log.info("pagePath: " + pagePath);

                // Create a node that represents the root node
                Node root = session.getRootNode();
                // Get page node from root
                Node pageNode = root.getNode(pagePath.substring(1));
                // Check pageNode is real node of page
                if(!isPageNode(pageNode)) {
                    continue;
                }

                // At this point we know that the node is a page
                Node pageContent = pageNode.getNode("jcr:content");

                if(!pageContent.hasProperty("jcr:description")) {
                    log.info("jcr:description of page content {} is empty", id);
                    continue;
                }


                // We are ready to process event
                logEventInfo(event);
                createNewPageVersion(pagePath);
            }



        } catch (Exception e) {
            log.info("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private boolean isExcludedProperty(String path) {

        final String[] excludeEls = new String[] {
//                        "jcr:isCheckedOut",
//                        "jcr:baseVersion",
//                        "cq:siblingOrder",
                        "jcr:lastModified",
                        "cq:lastModified"
                };

        for(String ex : excludeEls) {
            if(path.indexOf(ex) > -1) {
                log.info("Exclude element: " + ex);
                log.info("");
                return true;
            }
        }

        return false;
    }

    private String extractBaseFolder(String path) {

        int firstDoubleDot = path.indexOf(":");
        firstDoubleDot = (firstDoubleDot == -1) ? path.length() : firstDoubleDot;
        int firstLastSlash = path.lastIndexOf("/", firstDoubleDot);
        int secondLastSlash = path.lastIndexOf("/", firstLastSlash - 1);

        return path.substring(0, secondLastSlash);
    }

    private String extractPagePath(String path) {

        int pagePathLength = path.indexOf("/", EVENT_LISTENER_PATH.length() + 1);
        return path.substring(0, pagePathLength);
    }

    private boolean isPageNode(Node node) {

        // Check pageNode is real node of page
        boolean isPage = false;

        try {

            if (node.hasProperty("jcr:primaryType")) {
                Property prop = node.getProperty("jcr:primaryType");
                String primaryType = prop.getString();
                log.info("jcr:primaryType " + primaryType);
                isPage = "cq:Page".equals(primaryType);

            } else {
                log.info("Node don't have jcr:primaryType ");
            }

            if (!isPage) {
                log.info("Attention: it's not a page!");
            }
        }  catch (Exception e) {
            log.info("ERROR: " + e.getMessage());
            e.printStackTrace();
        }

        return isPage;
    }

    private void logEventInfo(Event event) {

        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(Event.NODE_ADDED, "Node added");
        map.put(Event.NODE_MOVED, "Node moved");
        map.put(Event.PROPERTY_ADDED, "Node property added");
        map.put(Event.PROPERTY_CHANGED, "Node property changed");
        map.put(Event.PROPERTY_REMOVED, "Node property removed");

        try {
            log.info("");
            log.info("*** Process Event ***");
            log.info(map.get( event.getType() ));
            log.info("Path: " + event.getPath() );
            log.info("Identifier: " + event.getIdentifier());
            log.info("User data: " + event.getUserData());
            log.info("User ID: " + event.getUserID());
            log.info("Info" + event.getInfo());
        }  catch (Exception e) {
            log.info("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void createNewPageVersion(String pagePath) {

        try {
            ResourceResolver resourceResolver = resolverFactory.getAdministrativeResourceResolver(null);
            //create a page manager instance
            PageManager pageManager = resourceResolver.adaptTo(PageManager.class);
            Page page = pageManager.getPage(pagePath);
            this.deactivate(componentContext);
            pageManager.createRevision(page);
            this.activate(componentContext);
            log.info("Page revision done!");

            log.info("");
        }  catch (Exception e) {
            log.info("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
