package edu.aem.training.eventhandler;

import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.jcr.api.SlingRepository;
import org.osgi.framework.BundleContext;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.jackrabbit.api.observation.JackrabbitEvent;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.observation.EventIterator;
import javax.jcr.observation.EventListener;
import javax.jcr.observation.ObservationManager;
import javax.jcr.observation.Event;
import java.util.Arrays;
import java.util.HashMap;


@Component(
        label = "AEM Event Listener Auto Versioning",
        immediate = true
)
@Service
public class AutoVersionEventListener implements EventListener {

    private final String EVENT_LISTENER_PATH = "/content/myapp";

    private Logger log = LoggerFactory.getLogger(this.getClass());

    private BundleContext bundleContext;

    @Reference
    private SlingRepository repository;

    @Reference
    private ResourceResolverFactory resolverFactory;

    private Session session;

    private ObservationManager observationManager;

    public void run() {
        log.info("Running...");
    }

    // Place app logic here to define the AEM Custom Event Handler
    protected void activate(ComponentContext ctx) {

        this.bundleContext = ctx.getBundleContext();

        try {
            // Invoke the adapTo method to create a Session
//            ResourceResolver resourceResolver = resolverFactory.getAdministrativeResourceResolver(null);
//            session = resourceResolver.adaptTo(Session.class);
            session = repository.loginAdministrative(null);

            // Setup the event handler to responde to a new claim under content/claim...
            observationManager = session.getWorkspace().getObservationManager();
            final String[] types = {"cq:Page"};
            // Define the path
            final String path = EVENT_LISTENER_PATH;
            observationManager.addEventListener(this,
                    Event.NODE_ADDED,// | Event.NODE_MOVED | Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED | Event.PROPERTY_REMOVED,
                    path,
                    false,        // [isDeep] events whose associated node is at path but not at its subtree
                    null,    // [uuid] events whose associated node has one of the UUID's in this list
                    types,   // [nodeTypeName] events whose associated node has one of the node types in this list
                    false      // [noLocal] events generated by the session through which the listener was registered aare not ignored
            );
            log.info("Observation property to {} nodes under {}", Arrays.asList(types), path);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected void deactivate(ComponentContext componentContext) throws RepositoryException {

        if(observationManager != null) {
            observationManager.removeEventListener(this);
        }

        if(session != null) {
            session.logout();
            session = null;
        }
    }

    // Define app logic that is fired when the even pccurs - simply track the time
    // when the event occured
    public void onEvent(EventIterator eventIterator) {
        log.info("onEvent");


        try {

            while (eventIterator.hasNext()) {

                Event event = eventIterator.nextEvent();

                HashMap<Integer, String> map = new HashMap<Integer, String>();
                map.put(Event.NODE_ADDED, "Page added");
                map.put(Event.NODE_MOVED, "Page moved");
                map.put(Event.PROPERTY_ADDED, "Page property added");
                map.put(Event.PROPERTY_CHANGED, "Page property changed");
                map.put(Event.PROPERTY_REMOVED, "Page property removed");

                String type = map.get( event.getType() );

                log.info("");
                log.info("*** Event ***");
                log.info(type);
                log.info("Path: " + event.getPath());
                log.info("Identifier: " + event.getIdentifier());
                log.info("User data: " + event.getUserData());
                log.info("User ID: " + event.getUserID());
                log.info("Path: " + event.getPath());
                log.info("Info" + event.getInfo());
                log.info("");

                // IMPORTANT!
                //
                // JCR Events are NOT cluster-aware and this event listener will be invoked on every node in the cluster.

                // Check if this event was spawned from the server this event handler is running on or from another
                if (event instanceof JackrabbitEvent && ((JackrabbitEvent) event).isExternal()) {
                    // Event did NOT originate from this server

                    // Skip, Let only the originator process;

                    // This is usual to avoid having the same processing happening for every node in a cluster. This
                    // is almost always the case when the EventListener modifies the JCR.

                    // A possible use-case for handling the event on EVERY member of a cluster would be clearing out an
                    // in memory (Service-level) cache.

                    return;
                } else {
                    // Event originated from THIS server
                    // Continue processing this Event
                }



            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
