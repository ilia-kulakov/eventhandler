package edu.aem.training.eventhandler;

import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.apache.jackrabbit.api.observation.JackrabbitEvent;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.event.jobs.Job;
import org.apache.sling.event.jobs.JobManager;
import org.apache.sling.jcr.api.SlingRepository;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.observation.Event;
import javax.jcr.observation.EventIterator;
import javax.jcr.observation.EventListener;
import javax.jcr.observation.ObservationManager;
import java.util.HashMap;
import java.util.Map;


@Component(
        label = "AEM Property Removal Event Listener",
        immediate = true
)
@Service
public class PropertyRemovalEventListener implements EventListener {

    private final String EVENT_LISTENER_PATH = "/content/myapp";

    private Logger log = LoggerFactory.getLogger(this.getClass());

    private ComponentContext componentContext;

    @Reference
    private SlingRepository repository;

    @Reference
    private ResourceResolverFactory resolverFactory;

    @Reference
    private JobManager jobManager;

    private Session session;

    private ObservationManager observationManager;

    public void run() {
        log.info("Running...");
    }

    // Place app logic here to define the AEM Custom Event Handler
    protected void activate(ComponentContext ctx) {

        this.componentContext = ctx;

        try {
            // Invoke the adapTo method to create a Session
//            ResourceResolver resourceResolver = resolverFactory.getAdministrativeResourceResolver(null);
//            session = resourceResolver.adaptTo(Session.class);
            session = repository.loginAdministrative(null);

            // Setup the event handler to responde to a new claim under content/claim...
            observationManager = session.getWorkspace().getObservationManager();
            // Define the path
            final String path = EVENT_LISTENER_PATH;
            observationManager.addEventListener(this,
                    Event.PROPERTY_REMOVED,
                    path,
                    true,        // [isDeep] events whose associated node is at path or within its subtree
                    null,    // [uuid] events whose associated node has one of the UUID's in this list
                    null,   // [nodeTypeName] events whose associated node has one of the node types in this list
                    false      // [noLocal] events generated by the session through which the listener was registered are not ignored
            );

            log.info("Observation property removal under {}", path);


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected void deactivate(ComponentContext componentContext) throws RepositoryException {

        if(observationManager != null) {
            observationManager.removeEventListener(this);
        }

        if(session != null) {
            session.logout();
            session = null;
        }
    }

    // Define app logic that is fired when the even occurs - simply track the time
    // when the event occured
    public void onEvent(EventIterator eventIterator) {
        log.info("onEvent");


        try {

            while (eventIterator.hasNext()) {

                Event event = eventIterator.nextEvent();

                // IMPORTANT!
                //
                // JCR Events are NOT cluster-aware and this event listener will be invoked on every node in the cluster.

                // Check if this event was spawned from the server this event handler is running on or from another
                if (event instanceof JackrabbitEvent && ((JackrabbitEvent) event).isExternal()) {
                    // Event did NOT originate from this server

                    // Skip, Let only the originator process;

                    // This is usual to avoid having the same processing happening for every node in a cluster. This
                    // is almost always the case when the EventListener modifies the JCR.

                    // A possible use-case for handling the event on EVERY member of a cluster would be clearing out an
                    // in memory (Service-level) cache.

                    continue;
                } else {
                    // Event originated from THIS server
                    // Continue processing this Event
                }

                String path = event.getPath();

                int lastSlash = path.lastIndexOf("/");
                String name = path.substring(lastSlash + 1);

                final Map<String, Object> props = new HashMap<String, Object>();
                props.put("path", path);
                props.put("name", name);

                log.info("Removal property name: " + name);
                log.info("Removal property path: " + path);

                Job job = jobManager.addJob("edu/aem/training/eventhandler/propertyremoval", props);

                if(job != null) {
                    log.info("Job is ready: " + job.getId());
                } else {
                    log.info("Failed add job");
                }
            }

        } catch (Exception e) {
            log.info("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }

}
